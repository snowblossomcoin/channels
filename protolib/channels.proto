syntax = "proto3";

option java_multiple_files = true;
option java_package = "snowblossom.channels.proto";
option java_outer_classname = "SnowBlossomChannelsProto";

package snowblossom.channels;

import "protolib/snowblossom.proto";

// The Stargate Service is the DHT network
service StargateService {
  rpc GetDHTPeers(GetDHTPeersRequest) returns (PeerList) {}
  rpc StoreDHTData(StoreDHTRequest) returns (DHTDataSet) {}
  rpc GetDHTData(GetDHTRequest) returns (DHTDataSet) {}
}

message StoreDHTRequest
{
  SignedMessage signed_dht_data = 1;
  int32 desired_result_count = 2;
}
message GetDHTRequest
{
  bytes element_id = 1;
  int32 desired_result_count = 2;
}

message DHTDataSet
{
  repeated SignedMessage dht_data = 1;
}

message DHTData
{
  bytes element_id = 1;
  ChannelPeerInfo peer_info = 2;
  bytes content_hash = 3;
}

message GetDHTPeersRequest {
  SignedMessage self_peer_info = 1;
}

message PeerList {
  repeated SignedMessage peers = 1;
}

message SignedMessage {
  bytes payload = 1; //A serialized SignedMessagePayload
  bytes signature = 2;
  bytes message_id = 4; // hash (payload_hash + signature)
}

message SignedMessagePayload {
  AddressSpec claim = 1;
  int64 timestamp = 2;
  bytes snow_block_hash = 3;
  oneof z {
    ChannelPeerInfo peer_info = 4;
    bytes tls_public_key = 5;
    DHTData dht_data = 6;

    ChannelBlock channel_block = 20;
    ContentInfo content_info = 21;
  }
}

message ChannelPeerInfo {
  map<string, ConnectInfo> connect_infos = 1;
  string version = 2;
  bytes address_spec_hash = 3; //Also the node ID
}

// The local information we store about a peer
message LocalPeerInfo {

  ChannelPeerInfo info = 1;
  SignedMessage signed_peer_info = 2;
  int64 last_connected = 3;
  int64 last_attempted = 4;
  int64 signed_timestamp = 5;
  double running_success_average = 6;
}

message ConnectInfo {
  string protocol = 1; //ipv4, ipv6, onion
  string host = 2;
  int32 port = 3;
}


// Actual channel stuff

message ChannelBlock {
  bytes channel_id=1;
  bytes block_hash=2;
  bytes prev_hash=3;
  int64 block_index=4;
  ChannelSettings settings=5; // If not set, use the most recent that is set

  repeated SignedMessage content = 10;

}

message ContentReference {
  bytes channel_id = 1;
  bytes message_id = 2;
  int32 importance = 3;
}

/* we will need a canonical content id that can be referenced
 * that way the messages can't be changed without breaking the reference chain.
 */
message ContentInfo {
  bytes content_hash = 1;
  string mime_type = 2;
  int64 content_length = 3;

  /* What this content is in reference to, if anything */
  ContentReference parent_ref = 4;
  repeated ContentReference refs = 5;
}

message ChannelSettings
{
  string display_name = 1;
  repeated bytes signer_address_spec_hash = 2;
  repeated DHTStrategy dht_strategies = 3;
  bool allow_outside_messages = 4;
  int64 required_outsider_snow_days = 5; // flakes * days required for staking
}

message DHTStrategy
{
  enum DHTMode {
    BASIC = 0;
  }
  DHTMode dht_mode = 1;
  int32 count = 2;
}
