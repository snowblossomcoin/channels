syntax = "proto3";

option java_multiple_files = true;
option java_package = "snowblossom.channels.proto";
option java_outer_classname = "SnowBlossomChannelsProto";

package snowblossom.channels;

import "protolib/snowblossom.proto";

// The Stargate Service is the DHT network
service StargateService {
  rpc GetDHTPeers(GetDHTPeersRequest) returns (PeerList) {}
  rpc StoreDHTData(StoreDHTRequest) returns (DHTDataSet) {}
  rpc GetDHTData(GetDHTRequest) returns (DHTDataSet) {}
}

service ChannelService {
  rpc SubscribePeering (  stream ChannelPeerMessage ) returns ( stream ChannelPeerMessage ) ;
}

message ChannelPeerMessage
{
  bytes channel_id = 1;
  oneof z {
    ChannelTip tip = 2;
    RequestBlock req_block = 3;
    ChannelBlock block = 4;

    RequestBlock req_header = 5;
    SignedMessage header = 6;

    RequestContent req_content = 7;
    SignedMessage content = 8;

    RequestChunk req_chunk = 9;
    ContentChunk chunk = 10;

  }
}

message ChannelTip
{
  SignedMessage block_header = 1;
  // This allows us to gossip channel peers without depending on DHT
  repeated ChannelPeerInfo peers = 2; 
}

message RequestBlock 
{
  oneof z {
    bytes block_hash = 2;
    int64 block_height = 3;
  }
}

message RequestContent
{
	bytes message_id = 1;
}

message RequestChunk
{
	bytes message_id = 1;
  int32 chunk = 2;
}

message ContentChunk
{
  bytes message_id = 1;
  int32 chunk = 2;

  oneof z {
    bytes chunk_data = 3;
    // if I can't supply the chunk in question, 
    // here is bit mapping of the ones I do have
    // Use with java.util.BitSet
    bytes chunk_have_bitmap = 4; 
  }
}

message StoreDHTRequest
{
  SignedMessage signed_dht_data = 1;
  int32 desired_result_count = 2;
}
message GetDHTRequest
{
  bytes element_id = 1;
  int32 desired_result_count = 2;
}

message DHTDataSet
{
  repeated SignedMessage dht_data = 1;
}

message DHTData
{
  bytes element_id = 1;
  ChannelPeerInfo peer_info = 2;
}

message GetDHTPeersRequest {
  SignedMessage self_peer_info = 1;
}

message PeerList {
  repeated SignedMessage peers = 1;
}

message SignedMessage {
  bytes payload = 1; //A serialized SignedMessagePayload
  bytes signature = 2;
  bytes message_id = 4; // hash (payload_hash + signature)
}

message SignedMessagePayload {
  AddressSpec claim = 1;
  int64 timestamp = 2;
  bytes snow_block_hash = 3;
  oneof z {
    ChannelPeerInfo peer_info = 4;
    bytes tls_public_key = 5;
    DHTData dht_data = 6;

    ChannelBlockHeader channel_block_header = 20;
    ContentInfo content_info = 21;
    ChannelSettings channel_settings = 22;
  }
}

message ChannelPeerInfo {
  map<string, ConnectInfo> connect_infos = 1;
  string version = 2;
  bytes address_spec_hash = 3; //Also the node ID
}

// The local information we store about a peer
message LocalPeerInfo {

  ChannelPeerInfo info = 1;
  SignedMessage signed_peer_info = 2;
  int64 last_connected = 3;
  int64 last_attempted = 4;
  int64 signed_timestamp = 5;
  double running_success_average = 6;
}

message ConnectInfo {
  string protocol = 1; //ipv4, ipv6, onion
  string host = 2;
  int32 port = 3;
}


// Actual channel stuff

message ChannelBlockHeader
{
  int32 version = 1;
  int64 block_height = 2;
  bytes channel_id = 3;
  bytes prev_block_hash = 4; //aka, prev signed header message_id
  bytes content_merkle = 6;  //merkle root of message_id of the signed content messages
  int64 timestamp = 7;
  int64 weight = 8; // Maybe make this only settable if signed by admin

  oneof z {
    ChannelSettings settings = 20;
    // Best chain is the chain with the highest sum(weight) + block_height.
    // 1) next tie breaker is head with earlier timestamp
    // 2) next tie breaker is head with lower message_id
    // So a block creator can leave the weights as zero and everything is fine.  If 
    // they need to revert some blocks with a fork, making a new block with a higher
    // weight will win.
    

    // Only set on first block (block zero).  The message ID from this
    // becomes the channel ID.
    // Note: the initial settings signer doesn't need to be any particular key. 
    // it doesn't need to be one of the admin keys.
    SignedMessage initial_settings = 21;
  }

}


message ChannelBlockSummary
{
  string work_sum = 1;
  bytes block_id = 2; //aka the message id of the signed header
  ChannelBlockHeader header = 3;
  ChannelSettings effective_settings = 4;
  SignedMessage signed_header = 5;
  bytes data_root_hash = 6;

}

message ChannelBlock {
  SignedMessage signed_header = 1;
  repeated SignedMessage content = 10;

}

message ContentReference {
  bytes channel_id = 1;
  bytes message_id = 2;


  // These modes give nodes a clue about if the data referenced should be included
  // when mirroring the channel
  enum ReferenceMode {
    INTEGRAL = 0; // Content in question is integral to this content and must be mirrored.  Parent content makes no sense without this.
    DIRECT = 1; // content in question is important and should be mirrored
    CITED = 5; // Content in question is meerly referenced by this content, not to be nessesarily mirrored
    TANGENT = 10; // Content in question is tangential and probably should not be mirrored
  }
  ReferenceMode ref_mode = 3;

}

/* we will need a canonical content id that can be referenced
 * that way the messages cant be changed without breaking the reference chain.
 * that id will be the message_id in the signed message
 */
message ContentInfo {
  bytes content_hash = 1;
  string mime_type = 2;
  int64 content_length = 3;

  bytes content = 4; // might be blank if content is large
  
  // Explicit list of channel's announced to - does not need to be set
  // but likely will need to be set to be picked up as a broadcast content
  // and included in a block.  But the block creator can include any content they want
  // regardless of this field
  repeated bytes broadcast_channel_ids = 5; 

  // Ordered list of hashes of 1MB blocks making up this content.
  // If the content size % 1mb != 0, then the last chunk is whatever is left.
  // must be set if content_length > 1mb
  repeated bytes chunk_hash = 6;

  /* What this content is in reference to, if anything */
  ContentReference parent_ref = 10;
  repeated ContentReference refs = 11;

  map<string, bytes> content_data_map = 12;

  // Things to be stored in the channel map.
  // The keys with prefix "www/" will be visible as static web files in the channel.
  // Note: those keys should point to message ids of content infos
  // Any prefixes can be used, but it is recommented to use "chandata/" for channel specific
  // data as other prefixes with special handling may be added.
  map<string, bytes> chan_map_updates = 20;
}


// A signed ChannelSettings is how a channel is founded
message ChannelSettings
{
  string display_name = 2;

  // These are folks who can create new blocks and do general mod functions like that
  repeated bytes block_signer_spec_hashes = 3;

  // These are folks who can update channel settings, (and thus add or remove signers).
  // Essentialy owners.  Anyone here can take over the channel.
  repeated bytes admin_signer_spec_hashes = 4;
  repeated DHTStrategy dht_strategies = 5;
  bool allow_outside_messages = 6;
  int64 required_outsider_snow_days = 7; // flakes * days required for staking
  int32 max_outsider_message_size = 8;
  int32 max_outsider_age_ms = 9;
}

message DHTStrategy
{
  enum DHTMode {
    BASIC = 0;
  }
  DHTMode dht_mode = 1;
  int32 count = 2;
  int64 period = 3; // Might have meaning depending on mode
  int64 period_mod = 4; // might have meaning depending on mode
}
