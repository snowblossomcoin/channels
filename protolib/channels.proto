syntax = "proto3";

option java_multiple_files = true;
option java_package = "snowblossom.channels.proto";
option java_outer_classname = "SnowBlossomChannelsProto";

package snowblossom.channels;

import "protolib/snowblossom.proto";

// The Stargate Service is the DHT network
service StargateService {
  rpc GetDHTPeers(GetDHTPeersRequest) returns (PeerList) {}
  rpc StoreDHTData(StoreDHTRequest) returns (DHTDataSet) {}
  rpc GetDHTData(GetDHTRequest) returns (DHTDataSet) {}
}

service ChannelService {
  rpc SubscribePeering ( stream ChannelPeerMessage ) returns ( stream ChannelPeerMessage ) ;
}

message ChannelPeerMessage
{
  oneof z {
    SignedMessage signed_update = 1;
    
  }
}

message StoreDHTRequest
{
  SignedMessage signed_dht_data = 1;
  int32 desired_result_count = 2;
}
message GetDHTRequest
{
  bytes element_id = 1;
  int32 desired_result_count = 2;
}

message DHTDataSet
{
  repeated SignedMessage dht_data = 1;
}

message DHTData
{
  bytes element_id = 1;
  ChannelPeerInfo peer_info = 2;
  bytes content_hash = 3;
}

message GetDHTPeersRequest {
  SignedMessage self_peer_info = 1;
}

message PeerList {
  repeated SignedMessage peers = 1;
}

message SignedMessage {
  bytes payload = 1; //A serialized SignedMessagePayload
  bytes signature = 2;
  bytes message_id = 4; // hash (payload_hash + signature)
}

message SignedMessagePayload {
  AddressSpec claim = 1;
  int64 timestamp = 2;
  bytes snow_block_hash = 3;
  oneof z {
    ChannelPeerInfo peer_info = 4;
    bytes tls_public_key = 5;
    DHTData dht_data = 6;

    ChannelBlockHeader channel_block_header = 20;
    ContentInfo content_info = 21;
    ChannelSettings channel_settings = 22;
  }
}

message ChannelPeerInfo {
  map<string, ConnectInfo> connect_infos = 1;
  string version = 2;
  bytes address_spec_hash = 3; //Also the node ID
}

// The local information we store about a peer
message LocalPeerInfo {

  ChannelPeerInfo info = 1;
  SignedMessage signed_peer_info = 2;
  int64 last_connected = 3;
  int64 last_attempted = 4;
  int64 signed_timestamp = 5;
  double running_success_average = 6;
}

message ConnectInfo {
  string protocol = 1; //ipv4, ipv6, onion
  string host = 2;
  int32 port = 3;
}


// Actual channel stuff

message ChannelBlockHeader
{
  int32 version = 1;
  bytes channel_id = 2;
  bytes prev_hash = 4; //aka, prev signed header message_id
  int64 block_index = 5;
  bytes content_merkle = 6;  //merkle root of message_id of the signed content messages
  int64 timestamp = 7;
  SignedMessage settings = 8; // If not set, use the most recent that is set
  int64 weight = 9;
  // Best chain is the chain with the highest sum(weight).
  // 1) next tie breaker is longest chain
  // 2) next tie breaker is head with earlier timestamp
  // 3) next tie breaker is head with lower message_id
  // So a block creator can leave the weights as zero and everything is fine.  If 
  // they need to revert some blocks with a fork, making a new block with a higher
  // weight will win.
}

message ChannelBlockSummary
{
  string work_sum = 1;
  ChannelBlockHeader header = 2;

}

message ChannelBlock {

  SignedMessage signed_header = 1;
  repeated SignedMessage content = 10;

}

message ContentReference {
  bytes channel_id = 1;
  bytes message_id = 2;


  // These modes give nodes a clue about if the data referenced should be included
  // when mirroring the channel
  enum ReferenceMode {
    INTEGRAL = 0; // Content in question is integral to this content and must be mirrored.  Parent content makes no sense without this.
    DIRECT = 1; // content in question is important and should be mirrored
    CITED = 5; // Content in question is meerly referenced by this content, not to be nessesarily mirrored
    TANGENT = 10; // Content in question is tangential and probably should not be mirrored
  }
  ReferenceMode ref_mode = 3;

}

/* we will need a canonical content id that can be referenced
 * that way the messages cant be changed without breaking the reference chain.
 * that id will be the message_id in the signed message
 */
message ContentInfo {
  bytes content_hash = 1;
  string mime_type = 2;
  int64 content_length = 3;

  bytes content = 4; // might be blank if content is large

  /* What this content is in reference to, if anything */
  ContentReference parent_ref = 10;
  repeated ContentReference refs = 11;
  repeated ContentInfo included_content = 12;
}


// A signed ChannelSettings is how a channel is founded
message ChannelSettings
{
  string display_name = 1;

  // These are folks who can create new blocks and do general mod functions like that
  repeated bytes block_signer_spec_hashes = 2;

  // These are folks who can update channel settings, (and thus add or remove signers).
  // Essentialy owners.  Anyone here can take over the channel.
  repeated bytes admin_signer_spec_hashes = 3;
  repeated DHTStrategy dht_strategies = 4;
  bool allow_outside_messages = 5;
  int64 required_outsider_snow_days = 6; // flakes * days required for staking
}

message DHTStrategy
{
  enum DHTMode {
    BASIC = 0;
  }
  DHTMode dht_mode = 1;
  int32 count = 2;
}
